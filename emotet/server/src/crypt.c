
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>

#include <openssl/evp.h>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/bn.h>
// #include "crypt/bn.h"

#define B_FORMAT_TEXT   0x8000
#define FORMAT_UNDEF    0
#define FORMAT_TEXT    (1 | B_FORMAT_TEXT)     /* Generic text */
#define FORMAT_BINARY   2                      /* Generic binary */
#define FORMAT_BASE64  (3 | B_FORMAT_TEXT)     /* Base64 */
#define FORMAT_ASN1     4                      /* ASN.1/DER */
#define FORMAT_PEM     (5 | B_FORMAT_TEXT)

#define HASH_FUNCTION EVP_sha256()
#define SESSION_KEY_ALG EVP_aes_128_ecb()
#define SESSION_KEY_ALG_NAME "aes-128-ecb"

static EVP_PKEY* PRVKEY;
static EVP_PKEY* PUBKEY;

void* Base642Bin
(
 const char *in,
 int        inLen,
 int        flags,
 PDWORD     outLen) {
  
  void* out = NULL;  
  // calculate how much space required
  if (CryptStringToBinary
      (in, inLen,
       flags, NULL, (PDWORD)outLen, NULL, NULL)) {
    out = malloc(*outLen);    
    if (out != NULL) {
      // decode base64
      CryptStringToBinary
	(in, inLen,
	 flags, out, (PDWORD)outLen, NULL, NULL);
    }
  }
  return out;
}

static uint8_t base64_decode0(uint8_t ch) {
  uint8_t ret = 0;
  if (ch >= 'A' && ch <= 'Z') {
    ret = ch - 'A';
  } else if (ch >= 'a' && ch <= 'z') {
    ret = ch - 'a' + 26;
  } else if (ch >= '0' && ch <= '9') {
    ret = ch - '0' + 52;
  } else if (ch == '+') {
    ret = 62;
  } else if (ch == '/') {
    ret = 63;
  } else {
    printf("not matched\n");
  }
  return (ret);
}

static uint32_t base64_decode1(uint8_t* p, uint8_t* out) {

  uint32_t a = base64_decode0(*p) << 18;
  // 4 * 6byte should be 24byte
  printf("ok,%p,%c,%p\n", p, *p, a);
  p++;
  a += base64_decode0(*p) << 12;
  printf("ok,%p,%c,%p\n",p, *p, a);
  p++;
  a += base64_decode0(*p) << 6;
  printf("ok,%p,%c,%p\n", p, *p, a);
  p++;
  a += base64_decode0(*p);
  printf("ok,%p,%c,%p\n", p, *p, a);
  *out = (a >> 0x10) & 0xff;
  *(out + 1) = (a >> 0x8) & 0xff;
  *(out + 2) = a & 0xff;  
  return a;
}

static uint8_t base64_decode2(uint8_t* p, uint8_t* q, uint8_t* out) {

  uint32_t r;
  uint8_t i = 0;
  for (;p < q && i<20;i++, p+=4, out+=3) {
    r = base64_decode1(p, out);
    printf("ok!!!,%p,%p\n", p, *p);
  }  
  // r = base64_decode1(p);
  // *out = r;
  // out++;  
}

void decode(void* der, uint32_t der_len) {
  
  void* derData = der;
  uint32_t derLen = 0;
  PCRYPT_PRIVATE_KEY_INFO pki = 0;
  uint32_t pkiLen = 0;
  // DWORD                     pkiLen, derLen, keyLen;
  uint8_t a = CryptDecodeObjectEx
    (
     X509_ASN_ENCODING,
     PKCS_PRIVATE_KEY_INFO,
     derData, der_len,
     CRYPT_DECODE_ALLOC_FLAG,
     NULL, &pki, &pkiLen);
  uint32_t* out = der;
  uint8_t* e = (uint8_t*)out + der_len;
  for (;out < e;out++) {
    printf("out:%p,%p,%p\n", out, *out, der_len);
  }  
  // printf("out:%p,%p,%d\n", out, *(uint8_t*)out, (p - q) * 4 / 3);
  printf("decodeobject!!!,%p,%p\n", a, GetLastError());  
}

void* pem_read_file
(
 const char* fname) {
  
  FILE *in;
  void *pem=NULL, *bin=NULL;
  HANDLE hFile = CreateFile
    (
     fname, GENERIC_ALL/* | GENERIC_EXECUTE*/, 0, NULL,
     OPEN_EXISTING/*CREATE_NEW*/, 0/*FILE_SHARE_READ*/, NULL
     );
  if (hFile == -1) {
    printf("file not found\n");
    return 0;
  }  
  DWORD wReadSize;
  DWORD size = GetFileSize(hFile , NULL);
  pem = malloc(size);
  ReadFile(hFile, pem, size, &wReadSize , NULL);
  printf("first byte:%p,%p,%p,%p\n",
	 *(uint64_t*)pem,*(((uint64_t*)pem)+1),*((uint64_t*)pem+2),*(((uint64_t*)pem)+3));
  uint8_t* p = pem;
  uint8_t* pem_end = p + size;
  for (;*p!=0x0a && p < pem_end;p++);
  p++;
  uint8_t* q = p;
  printf("pem:%p,%p,%c\n", p,*p,*p);
  for (;*p!=0x0a && p < pem_end;p++);
  
  CloseHandle(hFile);
  void* binLen = malloc(0x1000);
  
  printf("pemlen:%d,%d,%d,%d\n", size, strlen(pem), strlen(p), p - q);
  uint32_t* out = malloc(0x100);
  uint32_t outLen = 0;
  base64_decode2(q, p, out);
  /* int res = CryptStringToBinary */
  /*   (q, p - q, */
  /*    CRYPT_STRING_ANY/\*flags*\/, 0/\*out*\/, &outLen, NULL, NULL);   */
  /* printf("res:%d,%p,%p\n", res, outLen, *out); */
  /* res = CryptStringToBinary */
  /*   (q, p - q, */
  /*    CRYPT_STRING_ANY/\*flags*\/, out, &outLen, NULL, NULL); */
  /* printf("res:%d,%p,%p\n", res, outLen, *out); */
  decode(out, (p - q) * 3 / 4 + 3);
  
  /* bin = Base642Bin     */
  /*   (pem, strlen(pem), */
  /*    CRYPT_STRING_ANY, binLen); */
  
  /* if (st.st_size==0) { */
  /*   return NULL; */
  /* } */
  /* // open PEM file */
  /* in = fopen(ifile, "rb"); */

  /* if (in != NULL) { */
  /*   // allocate memory for data */
  /*   if (pem != NULL) { */
  /*     // read data */
  /*     fread(pem, 1, st.st_size, in); */
  if (bin != NULL) {
    // crypto API uses little endian convention
    // swap bytes for signatures
    // since there's no standard storage format
    /* if (pemType == RSA_SIGNATURE) { */
    /*   byte_swap(bin, *binLen); */
    /* } */
  }
  free(pem);
  /* fclose(in); */
  return out;
}

void* crypt_sign(EVP_PKEY* evp_pkey, void* d, int len) {
  
  EVP_MD_CTX *md;
  md = EVP_MD_CTX_create();
  int res = EVP_SignInit_ex(md, HASH_FUNCTION, NULL);
  printf("%d\n", res);
  // int bufLen = 4;
  // this signupdate will not compute anything but message digest.
  // making a signature will be done by signfinal.
  res = EVP_SignUpdate(md, d, len);
  printf("%d\n", res);
  // printf("sig:%p\n", *sig);
  
  uint32_t sigLen = EVP_PKEY_size(evp_pkey);
  uint32_t* sig = malloc(sigLen);
  printf("siglen:%d\n", sigLen);  
  res = EVP_SignFinal(md, sig, &sigLen, evp_pkey);
  printf("%d\n", res);
  
  EVP_MD_CTX_destroy(md);
  printf("sig:%p\n", *sig);
  return sig;
}

void* crypt_verify(EVP_PKEY* evp_pkey, void* d, int len, void* sig, int sig_len) {
  
  EVP_MD_CTX *md;
  md = EVP_MD_CTX_create();
  int res = EVP_VerifyInit_ex(md, HASH_FUNCTION, NULL);
  EVP_VerifyUpdate(md, d, len);
  int ok = EVP_VerifyFinal(md, sig, sig_len, evp_pkey);
  printf("ok:%d\n", ok);
  
  /* uint8_t    sig[MAX_RSA_BYTES]; */
  /* int        sigLen=0, bufLen; */
  return 0;
}

void derive_key(char* pass, void* key, void* iv) {
  
  void* sptr = 0;
  uint32_t islen = 0;
  uint8_t iter = 1;
  void* dgst = EVP_sha1();
  int res;  
  int iklen = 128/8;// EVP_CIPHER_key_length(&cipher);
  int ivlen = 128/8;// EVP_CIPHER_iv_length(&cipher);
  unsigned char tmpkeyiv[EVP_MAX_KEY_LENGTH + EVP_MAX_IV_LENGTH];  
  /* res = PKCS5_PBKDF2_HMAC(&str, strlen(str), sptr, islen, */
  /* 		    iter, dgst, iklen+ivlen, tmpkeyiv); */
  /* printf("res:%d,%p,%p\n", res, tmpkeyiv[0], tmpkeyiv[1]); */
  
  char cipher[] = "aes-128-ecb";
  EVP_CIPHER* ci = EVP_get_cipherbyname(&cipher);
  printf("ci:%p\n", ci);
  int size = EVP_CIPHER_block_size(ci);
  // void* iv = malloc(0x10);
  if (!EVP_BytesToKey
      (ci, dgst, sptr,
       (unsigned char *)pass,
       strlen(pass), 1, key, iv)) {
    printf("errrr\n");
    return 0;
  }
  return 1;
  printf("res!:%d,%p,%p\n", res, *(uint64_t*)key, *(uint64_t*)iv);  
}

void crypt_encrypt(void* src, int insize, char* key, char* iv) {
  
  /* int key_size = 0x10 * 2; */
  /* void* key = malloc(key_size); */
  /* uint8_t* p = key; */
  /* uint8_t* q = p + key_size; */
  /* memset(p, 0, key_size); */
  int res;
  EVP_CIPHER_CTX en;
  EVP_CIPHER_CTX_init(&en);  
  res = EVP_EncryptInit_ex(&en, SESSION_KEY_ALG, NULL, key, 1);  
  EVP_CIPHER_CTX_set_padding(&en, 0);  
  // printf("res:%d,%d\n", res, size);  
  uint64_t* out = malloc(128/8);
  void* outSize = 0;
  printf("%p\n", *out);  
  res = EVP_EncryptUpdate(&en, out, &outSize, src, insize);
  printf("res:%d,%d\n", res, outSize);
  printf("%p\n", *out);
  res = EVP_EncryptFinal_ex(&en, out, &outSize);
  EVP_CIPHER_CTX_cleanup(&en);
  printf("res:%d,%d\n", res, outSize);
  printf("%p,%p\n", *out, *(out+1));
  
}

void crypt_decrypt(void* src, int insize, void* key) {

  int res;  
  uint64_t* out = malloc(128/8);
  void* outSize = 0;  
  EVP_CIPHER_CTX en;
  EVP_CIPHER_CTX_init(&en);  
  res = EVP_DecryptInit_ex(&en, SESSION_KEY_ALG, NULL, key, 1);
  EVP_CIPHER_CTX_set_padding(&en, 0);
  res = EVP_DecryptUpdate(&en, out, &outSize, src, insize);
  res = EVP_DecryptFinal_ex(&en, out, &outSize);
  EVP_CIPHER_CTX_cleanup(&en);
  
}

void crypt_rsa_sign(EVP_PKEY *pkey, int in_len, void* in) {

  // from rsautl command,    
  RSA* rsa = EVP_PKEY_get1_RSA(pkey);  
  // int in_size = 0x10;
  // void* in = malloc(0x10);
  int keysize = RSA_size(rsa);
  void* out = malloc(keysize);
  unsigned char* pad = RSA_PKCS1_PADDING;  
  // RSA_NO_PADDING;// RSA_PKCS1_OAEP_PADDING;// 
  int rsa_outlen = RSA_private_encrypt(in_len, in, out, rsa, pad);
  printf("rsa outelen : %d, %d\n", keysize, rsa_outlen);  
}

void crypt_rsa_decrypt() {
  
  /* PEM_read_bio_RSAPublicKey(); */
  /* RSA_private_decrypt(); */
  // rsa->meth->rsa_priv_dec();  
  
}

void* crypt_debug_init(char* public_key_file_name) {
  FILE* f = fopen(public_key_file_name, "rb");
  PUBKEY = PEM_read_PUBKEY(f, 0, 0, 0);
  // void* sig = verify(PUBKEY, buf, 4);
  return PUBKEY;
}

void* crypt_init(char* private_key_file_name) {

  printf("ll:%s\n", private_key_file_name);
  OpenSSL_add_all_digests();
  OpenSSL_add_all_algorithms();
  FILE* f = fopen(private_key_file_name, "rb");
  // 
  PRVKEY = PEM_read_PrivateKey(f, 0, 0, 0);
  
  return PRVKEY;
  // printf("%p\n", evp_pkey);
  /* RSA* rsa = EVP_PKEY_get1_RSA(PRVKEY); */
  /* printf("%p,%p,%p\n", evp_pkey, rsa, evp_pkey->pkey.rsa); */
  /* printf("v:%p,%p,%p,%p,%p,%p\n", rsa->meth, */
  /* 	 rsa->n, rsa->e,rsa->d, *(uint32_t*)rsa->p,*(uint32_t*)rsa->q); */
  
  /* printf("numbytes:%p,%d,%d\n", (BIGNUM*)(rsa->n)->d, BN_num_bytes(rsa->n), BN_BYTES); */
  /* printf("numbytes:%p,%d,%d\n", *(uint32_t*)((BIGNUM*)(rsa->p)->d), BN_num_bytes(rsa->p), BN_BYTES); */
  
  
  // FILE *fp = fopen(stdout, "w");
  // RSA_print_fp(fp, rsa, 1);
  
  // BIO* bio = bio_open_owner(outfile, FORMAT_PEM, 1);
  
  // printf("bio:%p\n", bio)
  
  // void* der = pem_read_file(private_key_file_name);
  
  // private_key_file_name
  
  // in = fopen(ifile, "rb");
}



