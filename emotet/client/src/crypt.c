
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <stdint.h>

static uint8_t PUBKEY_DER_FORMAT[] =
  {
    0x30, 0x68, 0x02, 0x61, 0x00, 0xa9, 0x78, 0x33, 0xcd, 0x2e, 0xcb, 0x48, 0xdc, 0xc5, 0x48, 0x85,
    0x21, 0xa2, 0x49, 0xcb, 0x18, 0x07, 0x55, 0x59, 0xc5, 0xb4, 0x2a, 0xba, 0x6e, 0x2e, 0x9f, 0xdb,
    0x15, 0xcf, 0x87, 0xf5, 0xd4, 0x64, 0xdc, 0x8d, 0xf1, 0x45, 0xc3, 0x7b, 0x91, 0xf3, 0x85, 0x37,
    0x38, 0x93, 0x0a, 0x27, 0xf4, 0xc0, 0x59, 0x7d, 0xf3, 0x70, 0x14, 0xe2, 0x1c, 0xeb, 0x54, 0x1f,
    0x57, 0x72, 0xb7, 0x63, 0x31, 0x08, 0xfe, 0x4b, 0x5c, 0xc8, 0xda, 0x8a, 0x2d, 0x2e, 0xbb, 0x38,
    0xdc, 0x6c, 0x55, 0xea, 0x7b, 0xeb, 0xd4, 0x1d, 0x89, 0x54, 0x09, 0x5e, 0xb2, 0x1a, 0x16, 0x33,
    0x17, 0x2b, 0x3e, 0xaf, 0x8b, 0x02, 0x03, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00
  };

// this is the exact order on static area which are appeared on analyzed malwares.
static HCRYPTPROV HProv;
static HCRYPTKEY* HPubKey;
static HCRYPTKEY* HSessionKey;
static HCRYPTHASH HHash;

static int MESSAGE_SIZE;

#define PROVIDER_TYPE PROV_RSA_AES
#define SESSION_KEY_ALGORITHM CALG_AES_128
#define HASH_ALG CALG_SHA
// sha1 160bit(0x14byte)
#define HASH_BYTE 0x14

// ENCRYPTED_SESION_KEY_LEN < PUB_KEY_LEN because the former is a mode of the latter.
// this is actually length of der format.
#define PUB_KEY_LEN 0x60
// SIMPLEBLOB returns BLOB_HEADER as head 0xc byte.
#define PUB_KEY_BLOB_LEN PUB_KEY_LEN + 0xc

// this is max len
#define ENCRYPTED_SESION_KEY_LEN 0x70

int do_encrypt_init() {
  
  // 1st 
  // 2nd 
  // 3rd ;
  // 4th : PROV_RSA_AES(0x18)
  // 5th : CRYPT_VERIFYCONTEXT | CRYPT_SILENT  
  int ret = CryptAcquireContextW(&HProv, 0, 0, PROVIDER_TYPE, 0x0F0000040);
  if (ret == 0) goto error;
  
  CERT_PUBLIC_KEY_INFO* pub_key_info;
  int pub_key_info_len;
  // 1st : ENCODE_TYPE = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
  // 2nd : StructType = RSA_CSP_PUBLICKEYBLOB(0x13)
  // 3rd : pubKey
  // 4th : length
  // 5th : flags = CRYPT_ENCODE_ALLOC_FLAG(0x8000)
  // 6th : 0
  // 7th : output decoded 
  // 8th : 
  // void* PUBKEY_DER_FORMAT = ;
  ret = CryptDecodeObjectEx
    (0x10001, 0x13, &PUBKEY_DER_FORMAT[0], PUB_KEY_BLOB_LEN,
     0x8000, 0, &pub_key_info, &pub_key_info_len);
  if (ret == 0) goto error;
  
  ret = CryptImportKey(HProv, pub_key_info, pub_key_info_len, 0, 0, &HPubKey);
  if (ret == 0) goto error;
  
  // 1st: prov
  // 2nd: AlogID for session key (AT_KEYEXCHANGE/AT_SIGNATURE for key pair)
  // 3rd: dwFlags
  // 4th: key = CRYPT_EXPORTABLE(1)
  ret = CryptGenKey(HProv, SESSION_KEY_ALGORITHM, 1, &HSessionKey);
  if (ret == 0) goto error;
 
  // 1st: prov
  // 2nd: AlgID = CALG_SHA(0x8004)
  // 3rd: key (without key, set 0)
  // 3th: deflags = 0
  // 4th: hash object
  ret = CryptCreateHash(HProv, HASH_ALG, 0, 0, &HHash);
  if (ret == 0) goto error;
  return ret;
  
 error:
  printf("error reason:%p\n",GetLastError());
  return ret;
}

// only encrypted data size is not known.
// 0x60(encrypted key) + 0x14(hash) + encrypted data
void* concat_data(uint8_t* encrypted_ses_key, void* hash, void* encrypt_data, int data_size) {
  MESSAGE_SIZE = PUB_KEY_LEN + HASH_BYTE + data_size;
  uint8_t* copy_to = malloc(MESSAGE_SIZE);
  /* printf("e:%p,%p,%p,%p,%p\n", e, *e, *(e+1),*(e+2),*(e+3)); */
  memcpy(copy_to, encrypted_ses_key+0xc, PUB_KEY_LEN);
  memcpy(copy_to + PUB_KEY_LEN, hash, HASH_BYTE);
  memcpy(copy_to + PUB_KEY_LEN + HASH_BYTE, encrypt_data, data_size);
  
  return copy_to;
}

void* do_encrypt(void* data, int buf_len, int* len) {
  
  // 1st : original hash
  // 2nd : 0
  // 3rd : 0
  // 4th : hash which will be duprecated
  HCRYPTHASH dHash;
  int ret = CryptDuplicateHash(HHash, 0, 0, &dHash);
  if (ret == 0) goto error;
  // 1st : key
  // 2nd : hash
  // 3rd : final = true
  // 4th : flags
  // 5th : data
  // 6th : data len
  // 7th : buf len
  ret = CryptEncrypt(HSessionKey, dHash, 1, 0, data, len, buf_len);
  if (ret == 0) goto error;
  // Session key will be encrypted by pre-defined public key.
  // 1st : key which will be encrypted = HSessionKey
  // 2nd : key which encrypts the key set on 1st argument.
  // 3rd : SIMPLEBLOB(0x1) => export session key
  //       PUBLICKEYBLOB  => export public key
  //       PRIVATEKEYBLOB => export private key
  // 4th : dwflags : CRYPT_OAEP(0x40) => PKCS #1 version 2 formatting to be created with the RSA encryption and decryption
  // 5th : pointer to output data
  // 6th :
  void* encrypted_session_key = malloc(ENCRYPTED_SESION_KEY_LEN);
  buf_len = ENCRYPTED_SESION_KEY_LEN;
  ret = CryptExportKey(HSessionKey, HPubKey, 1, 0x40, encrypted_session_key, &buf_len);
  printf("encrypted session key len:%p\n", buf_len);
  if (ret == 0) goto error;
  // 1st : 
  // 2nd : HP_HASHVAL(2)
  // 3rd : 0
  // 4th : 
  // 5th : 0
  int size = HASH_BYTE;
  void* hash = malloc(size);
  ret = CryptGetHashParam(dHash, 2, hash, &size, 0);
  printf("session key len:%p\n", size);
  if (ret == 0) goto error;
  printf("crypt ok\n");
  
  void* r = concat_data(encrypted_session_key, hash, data, buf_len);
  
  return r;
  
 error:
  printf("error reason:%p\n", GetLastError());
  return 0;
}

int do_decrypt(void* data, int* len/*, i\]nt buf_len*/) {
  
  int ret;
  HCRYPTHASH dHash;
  ret = CryptDuplicateHash(HHash, 0, 0, &dHash);
  if (ret == 0) goto error;
  // 1st: hkey
  // 2nd: hash
  // 3rd: final
  // 4th: dflags
  // 5th: pData
  // 6th: datalen
  ret = CryptDecrypt(HSessionKey, dHash, 1, 0, data, len);
  printf("dec:%p\n", len);
  if (ret == 0) goto error;
  
  // 1st: hash
  // 2nd: signature
  // 3rd: len = 0x60
  // 4th: publicKey
  // 5th: description
  // 6th: flags
  /* void* sig; */
  /* ret = CryptVerifySignature(dHash, sig, 0x60, HPubKey, 0, 0); */
  printf("decrypt ok\n");
  return ret;
  
 error:
  printf("error reason:%p\n", GetLastError());
  return ret;
  
}



